# UniversalRenderer

UniversalRenderer provides a streamlined way to integrate Server-Side Rendering (SSR) with an external SSR service into your Rails application. It helps you forward rendering requests, manage static or streaming responses, and improve performance, SEO, and user experience for JavaScript-heavy frontends.

## Features

- Supports both static and streaming SSR.
- Configurable SSR server endpoint and timeouts.
- Helper methods for passing data to your SSR service.
- Automatic fallback to client-side rendering if SSR fails.
- View helpers for integrating SSR content into your layouts.

## Installation

1.  Add this line to your application's Gemfile:

    ```ruby
    gem "universal_renderer"
    ```

2.  And then execute:

    ```bash
    $ bundle install
    ```

3.  Run the install generator to create an initializer and include the necessary concern in your `ApplicationController`:

    ```bash
    $ rails generate universal_renderer:install
    ```

    This will:

    - Create `config/initializers/universal_renderer.rb`.
    - Add `include UniversalRenderer::Rendering` to your `app/controllers/application_controller.rb`.

## Configuration

Configure UniversalRenderer in `config/initializers/universal_renderer.rb`:

```ruby
UniversalRenderer.configure do |config|
  # (Required) The base URL of your SSR server.
  # Example: 'http://localhost:3001' or 'https://your-ssr-service.com'
  # Can also be set via the SSR_SERVER_URL environment variable.
  config.ssr_url = ENV.fetch("SSR_SERVER_URL", "http://localhost:3001")

  # (Optional) Timeout in seconds for requests to the SSR server.
  # Defaults to 3 seconds.
  # Can also be set via the SSR_TIMEOUT environment variable.
  config.timeout = (ENV["SSR_TIMEOUT"] || 3).to_i

  # (Optional) The path on your SSR server for streaming requests.
  # Defaults to '/stream'.
  # Can also be set via the SSR_STREAM_PATH environment variable.
  config.ssr_stream_path = ENV.fetch("SSR_STREAM_PATH", "/stream")
end
```

**Environment Variables:**
The `ssr_url`, `timeout`, and `ssr_stream_path` can be configured directly via environment variables (`SSR_SERVER_URL`, `SSR_TIMEOUT`, `SSR_STREAM_PATH`). If set, environment variables will take precedence over values in the initializer.

## Usage

The `universal_renderer:install` generator includes the `UniversalRenderer::Rendering` concern into your `ApplicationController`. This concern overrides `default_render` to automatically handle SSR.

### Rendering Flow Details

This gem facilitates communication with an external Node.js SSR server (like one built with the `universal-renderer` npm package).

**1. Static Rendering Flow:**

- When streaming is disabled or not applicable, the gem makes a `POST` request to the SSR server's static endpoint (by default, the root `/` of the `config.ssr_url`).
- The request includes the current URL and any props added via `add_props`.
- The SSR server is expected to return a JSON object (e.g., `{ "html_content": "...", "meta_tags": "...", "initial_state": { ... } }`).
- This JSON response is made available in your Rails view (typically `app/views/ssr/index.html.erb`) as the `@ssr` instance variable (with symbolized keys, e.g., `@ssr[:html_content]`).

**2. Streaming Rendering Flow:**

- **Layout Rendering & Splitting**:
  - Your Rails application (e.g., `app/views/layouts/application.html.erb`) begins to render. This layout **must** use the `<%= ssr_meta %>` helper at the point where SSR meta tags should be injected (usually late in the `<head>`) and `<%= ssr_body %>` where the main SSR application body should appear.
  - The `Rendering` concern captures the full layout string. It then splits this string at the `<!-- SSR_META -->` comment (generated by `<%= ssr_meta %>`).
  - The portion of the layout _before_ `<!-- SSR_META -->` is immediately written to the HTTP response stream and sent to the client.
- **Request to SSR Server**:
  - The gem then makes a `POST` request to the SSR server's streaming endpoint (configured by `config.ssr_stream_path`, default `/stream`).
  - The JSON payload of this request includes:
    - `url`: The current Rails request URL.
    - `props`: Data passed from your Rails controller using `add_props`.
    - `template`: This field contains the latter part of the rendered Rails view string, starting _directly with_ the `<!-- SSR_META -->` marker (generated by `<%= ssr_meta %>`) and continuing to the end of the document. This string must also include the `<!-- SSR_BODY -->` marker (generated by `<%= ssr_body %>`). The Node.js SSR server uses this `template` to construct the response around the streamed React application: it first sends the `<!-- SSR_META -->` part from the `template`, then injects its computed meta tags, then sends the HTML content found between `<!-- SSR_META -->` and `<!-- SSR_BODY -->` from the `template`. After this, the React application is streamed (filling the place of `<!-- SSR_BODY -->`), and finally, the portion of the `template` that was after `<!-- SSR_BODY -->` is appended.
- **Streaming Response**:
  - The Node.js SSR server streams HTML content back. This content is piped directly into the Rails response stream, filling the placeholders in the `template` it received.

**Fallback:**
If SSR (either static or streaming) fails in a way that allows for it, the system will typically fall back to rendering `app/views/application/index.html.erb`, which should contain your client-side rendering (CSR) entry point.

### Passing Data to SSR (`add_props`)

In your controllers, you can use the `add_props` method to pass data from your Rails application to the SSR service. This data will be available as a JSON object under the `props` key in the JSON payload sent to your SSR service.

`add_props` can be called in two ways:

1.  **Key-Value Pair:**

    ```ruby
    # In your controller action
    def show
      @product = Product.find(params[:id])
      add_props(:product, @product.as_json) # Ensure data is serializable
      add_props(:current_user_name, current_user.name)
      # ... default_render will be called implicitly
    end
    ```

    This will result in the `props` object in the SSR request payload being like:
    `{ "product": { ...product_data... }, "current_user_name": "User Name" }`

2.  **Hash Argument:**

    ```ruby
    # In your controller action
    def index
      @posts = Post.recent
      add_props(posts: @posts.map(&:as_json), current_page: params[:page])
      # ... default_render will be called implicitly
    end
    ```

    This will result in the `props` object in the SSR request payload being like:
    `{ "posts": [ ...posts_data... ], "current_page": "1" }`

Make sure any data passed is serializable to JSON (e.g., call `.as_json` on ActiveRecord objects).

### Templates

The gem relies on a few conventional template paths:

- `app/views/ssr/index.html.erb`: Used when `StaticClient` successfully receives data from the SSR server. This template typically uses the data (available in `@ssr`) to render the page.
- `app/views/application/index.html.erb`: This template is used as a fallback if SSR fails (e.g., SSR server is down, returns an error, or `StaticClient` receives no data). This usually contains your client-side rendering (CSR) entry point.

### View Helpers (`SsrHelpers`)

The `UniversalRenderer::SsrHelpers` module provides helpers to mark locations in your HTML structure. For streaming to work correctly with a compatible Node.js SSR server (like `universal-renderer`), these helpers (or the raw HTML comments they produce) are crucial in your main Rails layout (e.g., `app/views/layouts/application.html.erb`).

- `ssr_meta`: Placeholder for meta tags or other head elements generated by SSR. When used in a Rails layout for streaming, this helper outputs `<!-- SSR_META -->`, which the Node.js SSR server uses as an injection point.
- `ssr_body`: Placeholder for the main root element where your SSR application will be rendered. When used in a Rails layout for streaming, this helper outputs `<!-- SSR_BODY -->`, which the Node.js SSR server uses to stream the main application content into.
- `ssr_state`: Placeholder for embedding initial application state (e.g., as a JSON script tag) for client-side hydration.

**Example (`app/views/layouts/application.html.erb` for streaming):**

```erb
<!DOCTYPE html>
<html>
<head>
  <title>My App</title>
  <%= csrf_meta_tags %>
  <%= csp_meta_tag %>
  <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
  <%= ssr_meta %> <%# SSR service might inject specific meta tags here %>
</head>
<body>
  <div id="root">
    <%= ssr_body %> <%# SSR service streams the main application content here %>
  </div>
  <%= ssr_state %> <%# SSR service might inject a script tag with initial state here %>
  <%= javascript_importmap_tags %>
</body>
</html>
```

## SSR Server Expectations

Your external SSR server needs to meet the following expectations:

1.  **Static Rendering Endpoint (for `StaticClient`):**

    - **Path:** Root path (`/`) of the `config.ssr_url`.
      _Note: Some Node.js SSR servers like `universal-renderer` might default to a `/static` path. Ensure your SSR server listens on `/` for static requests if using this gem's default, or configure the Node.js server's `basePath` or routes accordingly._
    - **Method:** `POST`
    - **Request Body (JSON):**
      ```json
      {
        "url": "current_rails_request_original_url",
        "props": {
          // JSON object built from add_props calls
          // e.g., "product": { ... }, "current_user_name": "..."
        }
      }
      ```
    - **Successful Response:** `200 OK` with a JSON body. The structure of this JSON is up to you, but it will be available in your `app/views/ssr/index.html.erb` template as `@ssr` (with keys symbolized). Example:
      ```json
      {
        "html_content": "<div>Rendered Product</div>",
        "initial_state": { "product_id": 123 },
        "meta_tags": "<meta name='description' content='...'>"
      }
      ```

2.  **Streaming Rendering Endpoint (for `StreamClient`):**

    - **Path:** `config.ssr_stream_path` (defaults to `/stream`) on the `config.ssr_url`.
    - **Method:** `POST`
    - **Request Body (JSON):**
      ```json
      {
        "url": "current_rails_request_original_url",
        "props": {
          // User-defined props from add_props calls,
          // e.g., "product": { ... }, "current_user_name": "..."
        },
        "template": "<!-- SSR_META -->...HTML between meta and body...<!-- SSR_BODY -->...HTML after body...</html>"
      }
      ```
    - **Successful Response:** `200 OK` with `Content-Type: text/html`. The body should be an HTML stream. The Node.js SSR server will use the `template` field from the request body to inject content at the `<!-- SSR_META -->` and `<!-- SSR_BODY -->` placeholders.

## Example Controller

```ruby
# app/controllers/products_controller.rb
class ProductsController < ApplicationController
  def show
    @product = Product.find(params[:id])

    # Pass data to SSR service using add_props
    add_props(
      product: @product.as_json, # Ensure data is serializable
      related_products: @product.related_products.limit(5).as_json,
    )

    # default_render (from UniversalRenderer::Rendering) will be called automatically,
    # handling either streaming or static SSR based on configuration and environment.
  end
end
```

## Contributing

TODO

## License

The gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).
